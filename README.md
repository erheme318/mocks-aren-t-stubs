# Mocks Aren't Stubs


"Дууриамал объект" гэж жинхэнэ объектуудыг тестлэхийн тулд ашигладаг тусгай оъектуудыг нэрлэдэг бөгөөд нилээдгүй дэлгэрсэн нэршил юм. Ихэнх програмчлалын хэлний орчингууд одоо дууриамал объектуудыг хялбар үүсгэж болох өөр өөрсдийн гэсэн тогтолцоотой болцгоосон. Гэв ихэвчлэн хангалттай ойлгомжтой байдаггүй нэг зүйл нь юу вэ гэхлээр хэдийгээр дууриамал объект нь тестлэх зорилгоор ашиглагддаг нэг хэлбэрийн тусгай объект боловч, мөн нөгөөтэйгүүр тестлэх өөр нэг загварчлалын аргыг бий болгосон байдаг. Энэхүү нийтлэлээр би та бүхэнд дууриамал объект хэрхэн ашиглагддаг, үйлдэл шалгах явцыг (behavior verification) хэрхэн дэмждэг болон мөн хөгжүүлж, дэмжиж буй бүлгэмийн залуус хэрхэн өөр нэг тестлэх загварыг хөгжүүлж байгаа талаар тайлбарлах болно.

Би энэхүү "дууриамал объект" гэх нэршлийг анх хэдэн жилийн өмнө Extreme Programming (XP) бүлгэмийн нөхдүүдээс дуулж билээ. Түүнээс хойш энэхүү дууриамал объектууд миний сонирхлыг улам ихээр татах болсон. Нэг шалтгаан юу гэхлээр дууриамал объектуудын хөгжүүлэлтийг авч явж байсан нилээдгүй хөгжүүлэгчид надтай хамт ThoughtWorks-д хамт ажиллаж байсантай холбоотой байх. Нөгөө нэг шалтгаан нь юу гэвэл би энэхүү ойлголтыг XP -ын нөлөөлөлтэй тестлэх аргад тулгуурласан зохиол бүтээлүүдээс их харж байсантай ч холбоо байх.

Гэвч би энэхүү дууриамал объектуудын талаар муу тайлбарласан зүйлүүдтэй олонтаа таардаг. Ялангуяа хүмүүс эдгээр дууримал объектуудыг хэлтэрхий (stub) тай хольж хутгаад байдгыг би мэднэ. Яагаад хольж хутгаад байдгыг нь ч би сайн мэднэ - учир нь би өөрөө ч нэг хэсэг мөн тэгж харж байлаа. Харин тэдгээр дууриамал объектын хөгжүүлэгч нартай хийсэн ярилцлагууд намайг өчүүхэн ойлголтоос минь бүр цөм рүү нэвтрэн орж, нарийн мэдэхэд минь их тус болсон.

>**Тайлбар**:
Stub - тестэнд объектын зөвхөн зарим методын үйлдлийг дууриалгах зорилгоор ашиглагддаг тул хэлтэрхий объект гэж нэрлэсэн

Энэ ялгаа нь үнэндээ бол хоёр тусдаа ялгаатай зүйлүүд байгаа юм. Нэг талдаа тестийн үр дүнг хэрхэн батлах аргуудад ялгаа бий: объектын төлвийг батлах (state verification) болон объект хоорондын харьцаж буй үйлдлийг батлах (behavior verification). Нөгөөтэйгүүр тестлэх, загварчлах хоёрын хоорондоо хэрхэн нөлөөлж байгаа арга барил философи -д нь ялгаа бий. Энэ ялгааг би доор тайлбарлахдаа Тестээр хөтлөгдөх хөгжүүлэлт (Test Driven Development) -ын сонгодог болон дууриамал аргууд гэж нэрлэсэн болно.


## Ердийн тестүүд

Хоёр төрлийн аргыг энгийн жишээгээр тайлбарлаж эхэлье. (Жишээнүүд Жава хэл дээр бичигдсэн болохоос зарчмууд нь бусад бүх объект хандалтад програмчлалын хэл дээр ялгаагүй боломжтой.) Бидэнд Захиалга (Order) объект байгаа бөгөөд түүнийг Агуулах (Warehouse) объектоос дүүргэлт хийгддэг гэж үзье. Захиалга (Order) объект маш энгийн энгийн зөвхөн бараа (product) болон бүтээгдэхүүний тоо (quantity) хоёроос бүрддэг. Харин Агуулах (Warehouse) объект олон төрлийн бараануудын тооллого бүртгэлийг (inventory) агуулна. Бид Захиалга объектыг Агуулах -с өөрийгөө дүүргэ гэж хэлэх юм бол, бидэнд хоёр төрлийн хариулт өгөх боломжтой. Хэрэв агуулахад (Warehouse) байгаа бараа захиалга (Order) хийгдэхэд хангалттай бол, захиалга хийгдэж, агуулахын барааны дүн захиалсан барааны тоогоор буурна. Хэрэв агуулахад хангалттай бараа байхгүй бол, захиалга хийгдэхгүй ба агуулахад ямар ч өөрчлөлт орохгүй.

Эдгээр хоёр үйлдлүүд нилээдгүй хэдэн тестүүд дээр хийгдэх ба эдгээр нь доорх ердийн JUnit тестүүдтэй төстэй байх болов уу.

```java
public class OrderStateTester extends TestCase {
  private static String TALISKER = "Talisker";
  private static String HIGHLAND_PARK = "Highland Park";
  private Warehouse warehouse = new WarehouseImpl();

  protected void setUp() throws Exception {
    warehouse.add(TALISKER, 50);
    warehouse.add(HIGHLAND_PARK, 25);
  }
  public void testOrderIsFilledIfEnoughInWarehouse() {
    Order order = new Order(TALISKER, 50);
    order.fill(warehouse);
    assertTrue(order.isFilled());
    assertEquals(0, warehouse.getInventory(TALISKER));
  }
  public void testOrderDoesNotRemoveIfNotEnough() {
    Order order = new Order(TALISKER, 51);
    order.fill(warehouse);
    assertFalse(order.isFilled());
    assertEquals(50, warehouse.getInventory(TALISKER));
  }
```
  
xUnit тестүүд дараах дөрвөн төрлийн үе шатыг (phase) хийж гүйцэтгэдэг: setup, exercise, verify, teardown. Дээрх кодонд setup үе шат нь хагас нь setUp метод-д (Агуулах - warehouse -  объектыг байгуулахад), үлдсэн тал нь тест метод дотор (захиалга - order -  объектыг байгуулахад) хийгдсэн байна. order.fill гэж дуудаж байгаа нь exercise үе шат. Энэ үед бидний теслэх гээд хүсээд байгаа зүйлсийг маань объект гүйцэтгэх ёстой. assert (нотлох) шалгалтын зааврууд бол verification үе шат. Энд хэрэгжүүлсэн (exercised) метод шаардлагатай даалгаруудыг зөв гүйцэтгэсэн эсэхийг шалгана. Дээрх жишээн дээр tearDown үе шат яг тодорхой илэрхийлэгдээгүй ба garbage collector тэдгээрийг бидний өмнөөс нүдэнд харагдахгүй байдлаар хийж гүйцэтгэж байгаа.

setup үед бид 2 төрлийн объектыг үүсгэж байгаа. Order бол бидний тестлэж буй класс харин Order.fill -ыг ажиллуулахын тулд бидэнд Warehouse объект мөн хэрэг болж байгаа. Дээрхд дахин тодруулах нэг зүйл гэвэл: Order объект бол бидний тестлэх гэж анхаарлаа хандуулаад байгаа объект юм. Тестээр дагнаж мэргэшсэн хүмүүс үүнийг object-under-test, system-under-test гэх мэтээр нэрлэдэг. Хоёул хэлэхэд төвөгтэй, онцгүй нэрнүүд, хэдийгээр тийм ч олонд энэ чигээрээ илүү танигдсан нэршлүүд тул би мөн энэ чигээр нь ашиглаад явъя. Meszaros -н дагуу би System Under Test юмуу эсвэл бүүр товчлоод SUT гэх байдлаар тэмдэглээд явна.

Дээрх тестэнд надад нэг SUT (Order), нэг хамтрагч - collaborator - (warehouse) хэрэг болно. Хоёр шалтгааны улмаас надаа warehouse хэрэг болж байгаа: эхнийх нь тестлэгдэж буй бүхий л үйлдлүүдыг ямар ч асуудалгүйгээр ажиллуулахын тулд (Order.fill метод warehouse-ын методуудыг дуудаж буйгаа тул), хоёр дугаарт төлвийн баталгааг хийхийн тулд (Order.fill -с гарах аль нэг үр дүн warehouse -ын төлвийг өөрчлөх боломжтой учираас). Бид цаашид энэ сэдвийн талаар илүү судлаад, SUT болон хамтрагчуудын (collaborators) хоорондын олон зөрүүтэй ялгаа гаргаад ирэхээр та илүү олгох болно. (Өмнө нь би SUT -ыг “гол объект”, хамтрагчуудыг “хоёрдогч объект” гэх мэтээр нэрлэдэг байсан)

Энэхүү тестийн загвар нь төлөв батлах (state verification) арга юм. Юу гэсэн үг вэ гэхээр метод дуудагдаж, гүйцэтгэгдсэний дараа SUT болон хамтрагч нарын төлвийг шалгаж тэдгээр шалгагдаж буй методууд зөв ажилласан эсэхийг тодорхойлно. Дууриамал (Mock) объект шалгалтын өөр нэг боломжийг олгодогыг бид удахгүй харна болно.

## Дууриамал (Mock) объектуудтай тестүүд

Одоо би дээрхтэй ижил үйлдлүүдтэй боловч дууриамал объекттой тест бичье. Энэ кодонд би jMock санг ашиглан дууриамал объектуудыг тодорхойлно. jMock бол жава хэлний дууриамал объект-ын сан. Хэдийгээр өөр нилээдгүй хэдэн дууриамал объектын сангууд байдаг хэдий ч, энэ сан нь тэрхүү техникийг үүсгэгчдийн өөсрдийх нь бичсэн сан тул анхлан ашиглахад тохиромжтой.

```java
public class OrderInteractionTester extends MockObjectTestCase {
 private static String TALISKER = "Talisker";

 public void testFillingRemovesInventoryIfInStock() {
   //setup - data
   Order order = new Order(TALISKER, 50);
   Mock warehouseMock = new Mock(Warehouse.class);
   
   //setup - expectations
   warehouseMock.expects(once()).method("hasInventory")
     .with(eq(TALISKER),eq(50))
     .will(returnValue(true));
   warehouseMock.expects(once()).method("remove")
     .with(eq(TALISKER), eq(50))
     .after("hasInventory");

   //exercise
   order.fill((Warehouse) warehouseMock.proxy());
   
   //verify
   warehouseMock.verify();
   assertTrue(order.isFilled());
 }

 public void testFillingDoesNotRemoveIfNotEnoughInStock() {
   Order order = new Order(TALISKER, 51);    
   Mock warehouse = mock(Warehouse.class);
     
   warehouse.expects(once()).method("hasInventory")
     .withAnyArguments()
     .will(returnValue(false));

   order.fill((Warehouse) warehouse.proxy());

   assertFalse(order.isFilled());
 }
```


Доор гарах кодыг би нилээн хөнгөвчилсөн тул одоо цөмөөрөө testFillingRemovesInventoryIfInStock метод руу анхаарлаа хандуулцгаая.

Эхлэл хэсэгт, setup үе шат нь шал өөр байна. Эхний объектыг бүрдүүлэгч хэсэг маань 2 үндсэн хэсэгт хуваагдсан байна: өгөгдлөл (data) болон объектоос хүлээх амлалт(expectations). Өгөгдлийн (data) хэсэг бидний тестлэх гээд сонирхоод байгаа объектуудыг үүсгэж байна (уламжлалт аргатай ялгаагүй адилханаар). Ялгаа нь үүссэн объектууд нь байгаа. SUT нь ялгаагүй - захиалга (order) объект. Харин хамтрагч нь агуулах (warehouse) объект биш байгаа, түүний оронд дууриамал агуулах (warehouse) объект байна - яг тодорхой авч үзвэл Mock классын объект байгаа.

setup -ын хоёр дахь хэсэгт, дууриамал объект-с хүлээх амлалт (expectations) хийгдэж байна. Хүлээх амлалт нь SUT-г гүйцэтгэх үед дууриамал объектын аль метод нь дуудагдах ёстойг илэрхийлж байгаа.

Бүх хүлээх амлалтууд тодорхой болсны дараа би SUT-ыг ажилуулж, гүйцэтгэнэ. Гүйцэтгэл хийгдсэний дараа би хоёр төрлийн ойлголттой батлах үе шатыг хийж гүйцэтгэнэ: Assert-уудыг SUT -тэй жишиж шалгана (өмнөхтэй яг ижил). Мөн би дууриамал объектуудыг хүлээх амлалтуудынхаа дагуу дуудагдсан эхийг шалгана.

Хамгийн гол ялгаа нь бидний хэрхэн захиалга (order) объект агуулах (warehouse) объекттой харилцахдаа зөв үйлдлүүд хийж байгааг шалгахад л оршиж байгаа юм. Төлвөөр батлах аргаар бол бид агуулах объектын байгаа төлөвтэй жишиж шалгана. Дууриамал объект үйлдлээр батлах (behavior verification) аргаар буюу захиалга (order) объект агуулах (warehouse) объект руу хандахдаа зөв дуудсан эсэхийг шалгадаг: Ингэж шалгахын тулд бид дууриамал объектод юу хийгдэхийг нь setup үед хэлж, шалгах үед нь тэрхүү амлалтууд нь хийгдсэн эхийг нь асууж шалгадаг. Захиалга (order) объект л зөвхөн assert-уудтай жишигдэж шалгагдах ба хэрэв метод объектын төлвийг өөрчилдөггүй бол бидэнд ямар ч assert хэрэг болохгүй.

Хоёр дахь тестэнд би хэд хэдэн зүйлүүдийг өөрөөр хийсэн. Эхлээд би дууриамал объектыг өөрөөр үүсгэсэн, үүсгэгчийн (constructor) MockObjectTestCase-ын mock методыг ашигласан. Энэ метод нь jMock сан дахь хялбарчилсан метод бөгөөд надаа заавал тестийн сүүлд verify -ыг дуудаж шалгах шаардлагагүйгээр, автоматаар өөрөө шалгагдчихна. Би эхний тестэнд мөн ингэж шалгаж болох байсан ч дууриамал объектын шалгалт хэрхэн явагддагыг харуулах үүднээс зориудаар ашигласан болно.
Хоёр дахь тэстэн дэх дараагын нэг өөр зүйл юу гэвэл би хүлээх амлалт дахь (expectation) хязгаарлалтыг (constraints) бууруулж withAnyArguments -ыг ашигласан. Ингэсний шалгаан нь гэвэл эхний тестэнд агуулах (warehouse) -руу дамжуулагдах тоог шалгацан учираас үүнийг хоёр дахь тестэнд дахин давтаад байх шаардлагагүй учираас юм. Хэрэв логикийн дараалал нь өөрчлөгдөх болбол, зөвхөн нэг л тест амжилтгүй болно. Энэ тестүүдийн шилжилт өөрчлөлтүүдийг хялбар болгодог. Сан нь анхдагч байдлаараа withAnyArguments -ыг тодорхойлцон байдаг болохоор би энэ хэсгийг тэр чигээр нь аваад хаясан ч болно.

## Mocks болон Stubs объектуудын ялгаа

Анх эдгээр ойлголтууд гарч ирэхэд, олон хүмүүс дууриамал объектыг энгийн тестийн ухагдахуун болох stubs-тай хольж хутган, төөрөлдөж байсан. Түүнээс хойш хүмүүс тэдгээрийн ялгааг илүү ойлгосон байх. Хэдийгээр тиймч, хүмүүсийн хэрхэн mock -ыг ашигладгийг мэдэхийн тулд моск болон бусад тест doubles-уудыг мэдэх нь чухал (“doubles” ? хэрэв энэ таньд шинэ ойлголт бол санаа зоволтгүй, хэдхэн мөрийн дараа бүгд ойлгомжтой болно).

Програмын зөвхөн нэг элемент дээр тухайн агшинд санаагаа сайн төвлөрүүлэн та тест хийж байгаа бол энэ бол олны хэлдгээр unit testing юм. Асуудал нь юу вэ гэхлээр таньд ганц нэгжийг (unit) -ыг тестлэхийн тулд ихэвчлэн бусад нэгжүүд шаардлагатай болдог - бидний дээрх жишээн дээр warehouse хэрэг болсон шиг.

Дээрх миний харуулсан хоёр янзын тестын аргад, эхний нь жинхэнэ агуулах (warehouse) объектыг ашиглаж, харин хоёр дахь нь дууриамал агуулах (warehouse) объектыг (мэдээж энэ бол жинхэнэ объект биш) тус тус ашигласан. Хэдийгээр дууриамал объектыг ашиглах нь жинхэнэ агуулах объектыг ашиглахгүй байх нэг хэлбэр боловч мөн өөр төрлийн жинхэнэ биш объектуудыг иймэрхүү тестэд ашиглах боломжтой.

Эдгээр зүйлүүдийг тайлбарлахад хэрэглэгдэх нэршлүүд нилээд ярвигтай болж ирж байна - stub, mock, fake, dummy гэх зэрэг нэр томъёонууд гарч ирлээ. Энэхүү нийтлэлд би Gerard Meszaros -ын номонд дурьдсан нэршлүүдийг ашиглах болно. Хэдийгээр эдгээр нэр томъёонуудыг бүгд хэрэглэдэггүй ч гэсэн миний бодлоор эдгээр нэршлүүд бол нилээд сайн, мөн энэ миний эссэ учраас би аль нэршлийг сонгохоо өөрөө шийднэ.

Meszaros Test Double гэсэн нэрэн дор тестэнд ашиглагдах, жинхэнэ объектын оронд төлөөлөн ашиглагдаж байгаа аливаа объектуудыг ерөнхийлөн ингэж нэрлэсэн. Энэ нэршил нь киноны орлон тоглогч (Stunt Double) -с үүдэлтэй (Түүний ингэс ашигласан нэг шалгаан  нь өмнө хэдийн олон танигдсан нэршлээс зайлсхийх байсан). Meszaros дөрвөн төрлийн double -ыг тодорхойлсон:

Dummy шаардагдах параметерүүдийн тоог бөглөхөд л ашиглагдах объект бөгөөд хэзээ ч ашиглагдахгүй
Fake ерөнхий бүх зүйл нь асуудалгүй ажилладаг авч зарим нэг хялбарчилсан зүйлүүдээс болоод Production орчинд ашиглагдах боломжгүй объектууд (жишээ нь in memory өгөгдлийн бааз)
Stubs тестийн үед хийгдэх дуудлагуудад зориулж бэлдсэн хариултуудууд өгдөг, тестэнд программчлагдсан зүйлүүд нь уг тестээс гаднах ямар ч зүйлд хариулдаггүй. Stubs мөн аливаа дуудлагуудын мэдээллийг хадгалж болно. Жишээ нь email gateway stub магадгүй илгээсэн имэйлүүдээ юмуу аль эсвэл зөвхөн илгээсэн имэйлын тоог санадаг байж болно.
Mocks бидний энэхүү илтгэлд яригдаж байгаа сэдэв: Объектын дуудагдах байдал нь урьдчилан програмчлагдсан ба тэр нь тестийн үед заавал дуудагдах шаардлага болдог
Эдгээр double-уудаас зөвхөн mock л үйлдлээр батлах (behavior verification)-ыг шаарддаг. Бусад double-ууд ихэвчлэн төлвөөр батлах (state verification) -ыг хэрэглэдэг. Дууриамал объект (Mocks) нь exercise - үед SUT-ыг жинхэнэ хамрагч объектуудтай харьцаж байгаа гэж итгүүлэхийн тулд хийдэг үйлдлээрээ бусад double-уудтай яг ижил үйлдэл хийдэг. Хэдий тийм ч дууриамал объект setup болон verification үеүүдэд бусдаасаа ялгаатай.

Test double-уудын талаар илүү дэлгэрэнгүй судлах үүднээс бид жишээгээ өргөжүүлэх шаардлагатай болж байна. Олон хүмүүс test double-уудыг жинхэнэ объектуудтай ажиллахад ядаргаатай болсон үедээ ашиглаад байдаг. Test double-ыг ашиглах нэгэн түгээмэл жишээ нь: хэрэв захиалгын үед алдаа гарсан бол бид хэрэглэгч рүү имайлээр мэдээллэх шаардлагатай гэж үзье. Асуудал нь юу гэхлээр бид тестлэх үедээ жинхэнэ хэрэглэгчид рүү имэйлээр мэдээлэл явуулахыг хүсэхгүй. Тиймээс бид өөрсдөө удирдаж өөрчлөх боломжтой имэйлын системийн test double -ыг үүсгэе.

Одоо л бид дууриамал (mocks) болон stubs -уудын ялгааг таниж эхэлж байна. Хэрэв бид mailing -ны үйлдлийг тетслэж байсан бол бид энгийн stub -г дараах байдлаар бичих байсан байх.

```java
public interface MailService {
 public void send (Message msg);
}

public class MailServiceStub implements MailService {
 private List<Message> messages = new ArrayList<Message>();
 public void send (Message msg) {
   messages.add(msg);
 }
 public int numberSent() {
   return messages.size();
 }
}
```

Дээрх stub-д бид төлвөөр батлах (state verification) -г дараах байдлаар ашиглаж болно.

```java
class OrderStateTester...

public void testOrderSendsMailIfUnfilled() {
   Order order = new Order(TALISKER, 51);
   MailServiceStub mailer = new MailServiceStub();
   order.setMailer(mailer);
   order.fill(warehouse);
   assertEquals(1, mailer.numberSent());
 }
```
Мэдээж энэ бол маш энгийн тест - зөвхөн л мэдээлэл илгээсэн эсэхийг шалгаж байна. Бид имэйл яг зөвхөн хүндээ илгээгдсэн эсвэл яг зөв агуулга илгээгдсэн талаар тест хийгээгүй, хэдий тийм ч гол санаа нь харагдсан болов уу.

Дууриамал объектуудыг (mocks) ашиглавал дээрх тест нилээд өөр харагдана.

```java
class OrderInteractionTester...

public void testOrderSendsMailIfUnfilled() {
   Order order = new Order(TALISKER, 51);
   Mock warehouse = mock(Warehouse.class);
   Mock mailer = mock(MailService.class);
   order.setMailer((MailService) mailer.proxy());

   mailer.expects(once()).method("send");
   warehouse.expects(once()).method("hasInventory")
     .withAnyArguments()
     .will(returnValue(false));

   order.fill((Warehouse) warehouse.proxy());
 }
}
```

Дээрх хоёр тест хоёуланд нь би жинхэнэ mail service -ын оронд test double -ыг ашиглаж байна. Ялгаа нь stub ашигласан нь төлвөөр батлах (state verification) -г ашиглаж, харин дууриамал объект (mock) ашигласан нь үйлдлээр батлах (behavior verification)-ыг ашигласан байна.

Stub -д төлвөөр батлах (state verification) -г ашиглахын тулд надад зарим нэмэлт методуудыг stub дээр нэмж өгөх шаардлагатай болж байна - тэдгээр нь хариуг шалгахад ашиглагдах болно. Үүний үр дүнд stub нь MailService -г implement хийсэн боловч мөн нэмэлт тестын методуудаар нэмэгдсэн байна.
Дууриамал (mock) объектууд үргэлж үйлдлээр батлах (behavior verification)-ыг ашигладаг, харин stub альнаар нь ч байж болно. Meszaros үйлдлээр батлах (behavior verification)-ыг ашигладаг stub -уудыг Test Spy гэж нэрлэсэн. Ялгаа нь тухайн double хэрхэн гүйцэтгэгдэж, хэрхэн үр дүнгээ шалгаж байгаад оршиж байгаа. Үүнийг би таньд үлдээлээ, та цааш судлаж ялгааг нь олоорой.

## Сонгодог болон дууриамал тестийн арга

Одоо би хоёр дахь ялгаа болох сонгодог болон дууриамал TDD -ийн ялгааны талаар судлах боломжтой боллоо. Гол асуудал маань яг хэзээ дууримал объект (бусад Double)  -уудыг хэрэглэх вэ юм.

Сонгодог TDD -ын загвараар бол болж өгвөл аль болох жинхэнэ объектуудыг ашиглаж харин жинхэнийг ашиглахад төвөгтэй үед double -ыг ашиглахыг зөвлөдөг. Тиймээс сонгодог TDD аргаар хөгжүүлэгчид жинхэнэ агуулах (warehouse) объектыг ашиглаж харин mail service -ын оронд double-ыг ашиглах байсан байх. Харин ямар төрлийн double нь тийм ч  чухал зүйл биш.

Дууриамал TDD загвараар хөгжүүлэгчид харин үргэлж дууриамал объектыг бүх төрлийн элдэвийн үйлдлүүдтэй объектын оронд ашигладаг. Дээрх жишээнд агуулах (warehouse) болон mail service хоёрын хоёулангых нь оронд дууриамал объектыг ашиглах байсан.

Хэдийгээр дууримал тестийн фраймворкууд дууримал тестийн загварт зориулж хийгдсэн байдаг хэдий ч олон сонгодог загвараар хөгжүүлэгчид тэдгээрийг double-уудыг үүсгэж, ашигладах хялбар гэж үздэг.

Дууриамал загварын нэгэн гол урсгал нь Behavior Driven Development(BDD) юм. BDD -ыг анхлан надтай хамт ажилладаг Dan North хөгжүүлсэн ба  хүмүүст Test Driven Development аргаар хөгжүүлж сурахад нь туслах ингэхдээ TDD хэрхэн загварчлалын нэгэн техник арга мэт ажилладаг гэдгийг онцлож өгөхийг зорьсон. Энэ нь цаашлан TDD хөгжүүлэлтийн арга нь объект яг юу хийх ёстой талаар бодоход тусладаг болохоор түүнийг сайтар судалж ойлгохын үүднээс тестүүдийг илүү үйлдлүүдээр нь тодорхойлж нэрлэхэд хүргэсэн. BDD дууриамал объектуудын аргаар замнасан хэдий боловч нэршүүлэх мөн энэ аргад анализыг нэвтрүүлэх зэрэг нь түүнийг цаашид улам тэлж өгсөн. Би үүний талаар илүү нарийн зүйлийг энд өгүүлэхгүй, учир нь энэ нийтлэлд зөвхөн хамаатай зүйл нь BDD бол дууриамал загварын аргаар илүү хөтлөгдсөн TDD-ын нэг хувилбар гэдгийг хэлэх гэсэн юм. Илүү дэлгэрэнгүй мэдээллийг та дээрх холбоосоор орон мэдэх боложтой тул үүнийг би таньд үлдээлээ.

Та заримдаа “Детройт” загвар нь “сонгодог”-т харин “Лондон” нь “дууримал аргаар” хөгжүүлэгчидэд гэсэн байхыг хардаг байх. Энэ нь XP нь анх Детройт-д C3 төслөөс үүсэн хөгжүүлэгдсэн бол харин дууриамал загварчлалын арга нь анх Лондонгийн  XP -г нутагшуулсан хүмүүс хөгжүүлсэн гэсэн баримтаас үүдэлтэй юм. Би мөн нэг зүйлийг хэлэхгүй өнгөрч болохгүй нь, юу гэвэл олон дууриамал аргаар хөгжүүлдэг хөгжүүлэгчид “mockist” гэсэн нэршил болон сонгодог болон дууриамал аргуудыг тусд нь ялгасан ямар нэгэн техникийн хэллэгүүдэд дургүй байдаг. Тэд хоёр загварчлалын аргыг ялгаж үзэх ямар нэгэн шаардлага хэрэгцээ байгаа гэж үздэггүй.

## Ялгаануудын дундаас сонгох

//Удахгүй орно

### TDD -р хөтлөгдөх

//Удахгүй орно

### Тестийн өгөгдлийг тодорхойлох

//Удахгүй орно

### Тестийн тусгаарлалт

//Удахгүй орно

### Тестээ хэрэгжүүлэлтэйгээ холбох

//Удахгүй орно

### Загварчлалын төрөл

//Удахгүй орно

## Тэгэхээр би сонгодог уу эсвэл дууриамал аргаар тестлэгч үү

//Удахгүй орно

## Төгсгөлийн бодлууд

//Удахгүй орно









## Үг зүй:

Mock object - Дууриамал объект
Stub - нэг юмны хэлтэрхий тал, тестэнд ашиглахдаа объектын зөвхөн хэрэг болох хэсгийг нь л зааж өгч ашигладаг
Framework - Тогтолцоо
Order - Захиалга
Product - Бараа
Quantity - Бүтээгдэхүүний тоо
Warehouse - Агуулах
Set up - Байгуулах
Inventory - Бараа бүтээгдэхүүний тооллого
Behavoir - Үйлдэл
Community - Бүлгэм
state verification - Төлвийн баталгаа
object-under-test  - тестлэгдэж буй объект
Primary object - Гол оъект
Secondary object - Хоёрдогч объект
Collaborator - Хамтрагч
Library - Сан
Data - Өгөгдөл
Expectation - Тэгэх байх гэсэн хүлээлт, амлалт
Exercise - Хийж, гүйцэлдүүлэх
Assert - Нотолгоо, нотлох
Constructor - Үүсгэгч
Constraint - Хялгаарлалт
Fail - ажилтгүй болох
Call - дуудлага (жишээ нь: method call - методыг дуудах)