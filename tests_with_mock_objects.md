## Дуураймал (Mock) объектуудтай тестүүд

Одоо би дээрхтэй ижил үйлдлүүдтэй боловч дуураймал объекттой тест бичье. Энэ кодонд би jMock санг ашиглан дуураймал объектуудыг тодорхойлно. jMock бол жава хэлний дуураймал объект-ын сан. Хэдийгээр өөр нэлээдгүй хэдэн дуураймал объектын сангууд байдаг хэдий ч, энэ сан нь тэрхүү техникийг үүсгэгчдийн өөсрдийх нь бичсэн сан тул анхлан ашиглахад тохиромжтой.

```java
public class OrderInteractionTester extends MockObjectTestCase {
 private static String TALISKER = "Talisker";

 public void testFillingRemovesInventoryIfInStock() {
   //setup - data
   Order order = new Order(TALISKER, 50);
   Mock warehouseMock = new Mock(Warehouse.class);
   
   //setup - expectations
   warehouseMock.expects(once()).method("hasInventory")
     .with(eq(TALISKER),eq(50))
     .will(returnValue(true));
   warehouseMock.expects(once()).method("remove")
     .with(eq(TALISKER), eq(50))
     .after("hasInventory");

   //exercise
   order.fill((Warehouse) warehouseMock.proxy());
   
   //verify
   warehouseMock.verify();
   assertTrue(order.isFilled());
 }

 public void testFillingDoesNotRemoveIfNotEnoughInStock() {
   Order order = new Order(TALISKER, 51);    
   Mock warehouse = mock(Warehouse.class);
     
   warehouse.expects(once()).method("hasInventory")
     .withAnyArguments()
     .will(returnValue(false));

   order.fill((Warehouse) warehouse.proxy());

   assertFalse(order.isFilled());
 }
```


Доор гарах кодыг би нилээн хөнгөвчилсөн тул одоо цөмөөрөө testFillingRemovesInventoryIfInStock метод руу анхаарлаа хандуулцгаая.

Эхлэл хэсэгт, setup үе шат нь шал өөр байна. Эхний объектыг бүрдүүлэгч хэсэг маань 2 үндсэн хэсэгт хуваагдсан байна: өгөгдөл (data) болон объектоос хүлээх амлалт(expectations). Өгөгдлийн (data) хэсэг бидний тестлэх гээд сонирхоод байгаа объектуудыг үүсгэж байна (уламжлалт аргатай ялгаагүй адилхнаар). Ялгаа нь үүссэн объектууд нь байгаа. SUT нь ялгаагүй - захиалга (order) объект. Харин хамтрагч нь агуулах (warehouse) объект биш байгаа, түүний оронд дуураймал агуулах (warehouse) объект байна - яг тодорхой авч үзвэл Mock классын объект байгаа.

setup -ын хоёр дахь хэсэгт, дуураймал объект-с хүлээх амлалт (expectations) хийгдэж байна. Хүлээх амлалт нь SUT-г гүйцэтгэх үед дуураймал объектын аль метод нь дуудагдах ёстойг илэрхийлж байгаа.

Бүх хүлээх амлалтууд тодорхой болсны дараа би SUT-ыг ажиллуулж, гүйцэтгэнэ. Гүйцэтгэл хийгдсэний дараа би хоёр төрлийн ойлголттой батлах үе шатыг хийж гүйцэтгэнэ: Assert-уудыг SUT -тэй жишиж шалгана (өмнөхтэй яг ижил). Мөн би дуураймал объектуудыг хүлээх амлалтуудынхаа дагуу дуудагдсан эхийг шалгана.

Хамгийн гол ялгаа нь бидний хэрхэн захиалга (order) объект агуулах (warehouse) объекттой харилцахдаа зөв үйлдлүүд хийж байгааг шалгахад л оршиж байгаа юм. Төлөвөөр батлах аргаар бол бид агуулах объектын байгаа төлөвтэй жишиж шалгана. Дуураймал объект үйлдлээр батлах (behavior verification) аргаар буюу захиалга (order) объект агуулах (warehouse) объект руу хандахдаа зөв дуудсан эсэхийг шалгадаг: Ингэж шалгахын тулд бид дуураймал объектод юу хийгдэхийг нь setup үед хэлж, шалгах үед нь тэрхүү амлалтууд нь хийгдсэн эхийг нь асууж шалгадаг. Захиалга (order) объект л зөвхөн assert-уудтай жишигдэж шалгагдах ба хэрэв метод объектын төлөвийг өөрчилдөггүй бол бидэнд ямар ч assert хэрэг болохгүй.

Хоёр дахь тестэд би хэд хэдэн зүйлүүдийг өөрөөр хийсэн. Эхлээд би дуураймал объектыг өөрөөр үүсгэсэн, үүсгэгчийн (constructor) MockObjectTestCase-ын mock методыг ашигласан. Энэ метод нь jMock сан дахь хялбарчилсан метод бөгөөд надаа заавал тестийн сүүлд verify -ыг дуудаж шалгах шаардлагагүйгээр, автоматаар өөрөө шалгагдчихна. Би эхний тестэд мөн ингэж шалгаж болох байсан ч дуураймал объектын шалгалт хэрхэн явагддагийг харуулах үүднээс зориудаар ашигласан болно.
Хоёр дахь тэстэн дэх дараагийн нэг өөр зүйл юу гэвэл би хүлээх амлалт дахь (expectation) хязгаарлалтыг (constraints) бууруулж withAnyArguments -ыг ашигласан. Ингэсний шалгаан нь гэвэл эхний тестэд агуулах (warehouse) -руу дамжуулагдах тоог шалгацан учраас үүнийг хоёр дахь тестэд дахин давтаад байх шаардлагагүй учраас юм. Хэрэв логикийн дараалал нь өөрчлөгдөх болбол, зөвхөн нэг л тест амжилтгүй болно. Энэ тестүүдийн шилжилт өөрчлөлтүүдийг хялбар болгодог. Сан нь анхдагч байдлаараа withAnyArguments -ыг тодорхойлсон байдаг болохоор би энэ хэсгийг тэр чигээр нь аваад хаясан ч болно.