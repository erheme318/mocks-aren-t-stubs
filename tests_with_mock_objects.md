## Дууриамал (Mock) объектуудтай тестүүд

Одоо би дээрхтэй ижил үйлдлүүдтэй боловч дууриамал объекттой тест бичье. Энэ кодонд би jMock санг ашиглан дууриамал объектуудыг тодорхойлно. jMock бол жава хэлний дууриамал объект-ын сан. Хэдийгээр өөр нилээдгүй хэдэн дууриамал объектын сангууд байдаг хэдий ч, энэ сан нь тэрхүү техникийг үүсгэгчдийн өөсрдийх нь бичсэн сан тул анхлан ашиглахад тохиромжтой.

```java
public class OrderInteractionTester extends MockObjectTestCase {
 private static String TALISKER = "Talisker";

 public void testFillingRemovesInventoryIfInStock() {
   //setup - data
   Order order = new Order(TALISKER, 50);
   Mock warehouseMock = new Mock(Warehouse.class);
   
   //setup - expectations
   warehouseMock.expects(once()).method("hasInventory")
     .with(eq(TALISKER),eq(50))
     .will(returnValue(true));
   warehouseMock.expects(once()).method("remove")
     .with(eq(TALISKER), eq(50))
     .after("hasInventory");

   //exercise
   order.fill((Warehouse) warehouseMock.proxy());
   
   //verify
   warehouseMock.verify();
   assertTrue(order.isFilled());
 }

 public void testFillingDoesNotRemoveIfNotEnoughInStock() {
   Order order = new Order(TALISKER, 51);    
   Mock warehouse = mock(Warehouse.class);
     
   warehouse.expects(once()).method("hasInventory")
     .withAnyArguments()
     .will(returnValue(false));

   order.fill((Warehouse) warehouse.proxy());

   assertFalse(order.isFilled());
 }
```


Доор гарах кодыг би нилээн хөнгөвчилсөн тул одоо цөмөөрөө testFillingRemovesInventoryIfInStock метод руу анхаарлаа хандуулцгаая.

Эхлэл хэсэгт, setup үе шат нь шал өөр байна. Эхний объектыг бүрдүүлэгч хэсэг маань 2 үндсэн хэсэгт хуваагдсан байна: өгөгдлөл (data) болон объектоос хүлээх амлалт(expectations). Өгөгдлийн (data) хэсэг бидний тестлэх гээд сонирхоод байгаа объектуудыг үүсгэж байна (уламжлалт аргатай ялгаагүй адилханаар). Ялгаа нь үүссэн объектууд нь байгаа. SUT нь ялгаагүй - захиалга (order) объект. Харин хамтрагч нь агуулах (warehouse) объект биш байгаа, түүний оронд дууриамал агуулах (warehouse) объект байна - яг тодорхой авч үзвэл Mock классын объект байгаа.

setup -ын хоёр дахь хэсэгт, дууриамал объект-с хүлээх амлалт (expectations) хийгдэж байна. Хүлээх амлалт нь SUT-г гүйцэтгэх үед дууриамал объектын аль метод нь дуудагдах ёстойг илэрхийлж байгаа.

Бүх хүлээх амлалтууд тодорхой болсны дараа би SUT-ыг ажилуулж, гүйцэтгэнэ. Гүйцэтгэл хийгдсэний дараа би хоёр төрлийн ойлголттой батлах үе шатыг хийж гүйцэтгэнэ: Assert-уудыг SUT -тэй жишиж шалгана (өмнөхтэй яг ижил). Мөн би дууриамал объектуудыг хүлээх амлалтуудынхаа дагуу дуудагдсан эхийг шалгана.

Хамгийн гол ялгаа нь бидний хэрхэн захиалга (order) объект агуулах (warehouse) объекттой харилцахдаа зөв үйлдлүүд хийж байгааг шалгахад л оршиж байгаа юм. Төлвөөр батлах аргаар бол бид агуулах объектын байгаа төлөвтэй жишиж шалгана. Дууриамал объект үйлдлээр батлах (behavior verification) аргаар буюу захиалга (order) объект агуулах (warehouse) объект руу хандахдаа зөв дуудсан эсэхийг шалгадаг: Ингэж шалгахын тулд бид дууриамал объектод юу хийгдэхийг нь setup үед хэлж, шалгах үед нь тэрхүү амлалтууд нь хийгдсэн эхийг нь асууж шалгадаг. Захиалга (order) объект л зөвхөн assert-уудтай жишигдэж шалгагдах ба хэрэв метод объектын төлвийг өөрчилдөггүй бол бидэнд ямар ч assert хэрэг болохгүй.

Хоёр дахь тестэнд би хэд хэдэн зүйлүүдийг өөрөөр хийсэн. Эхлээд би дууриамал объектыг өөрөөр үүсгэсэн, үүсгэгчийн (constructor) MockObjectTestCase-ын mock методыг ашигласан. Энэ метод нь jMock сан дахь хялбарчилсан метод бөгөөд надаа заавал тестийн сүүлд verify -ыг дуудаж шалгах шаардлагагүйгээр, автоматаар өөрөө шалгагдчихна. Би эхний тестэнд мөн ингэж шалгаж болох байсан ч дууриамал объектын шалгалт хэрхэн явагддагыг харуулах үүднээс зориудаар ашигласан болно.
Хоёр дахь тэстэн дэх дараагын нэг өөр зүйл юу гэвэл би хүлээх амлалт дахь (expectation) хязгаарлалтыг (constraints) бууруулж withAnyArguments -ыг ашигласан. Ингэсний шалгаан нь гэвэл эхний тестэнд агуулах (warehouse) -руу дамжуулагдах тоог шалгацан учираас үүнийг хоёр дахь тестэнд дахин давтаад байх шаардлагагүй учираас юм. Хэрэв логикийн дараалал нь өөрчлөгдөх болбол, зөвхөн нэг л тест амжилтгүй болно. Энэ тестүүдийн шилжилт өөрчлөлтүүдийг хялбар болгодог. Сан нь анхдагч байдлаараа withAnyArguments -ыг тодорхойлцон байдаг болохоор би энэ хэсгийг тэр чигээр нь аваад хаясан ч болно.