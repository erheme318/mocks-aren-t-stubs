# Ялгаануудаас сонгох

Энэ нийтлэлд би дараах хос ялгаануудын талаар тайлбарлана: төлвөөр (state) батлах уу эсвэл үйлдлээр батлах уу / сонгодог TDD юу эсвэл дууриамал ТDD юу. Дээрх аргуудын нэгийг сонгохдоо ямар зарчмуудыг баримтлах хэрэгтэй вэ ? Эхлээд үйлдлээр батлахын эсрэг төлвөөр батлах аргыг авч үзье.

Эхний авч үзэх шаардлагатай зүйл нь тухайн нөхцөл байдал (context) юм. Бидний ажиллаж буй объект хоорондын харилцаа (collaboration) *захиалга* (order) болон *агуулах* (warehouse) хоёртой адилхан хялбархан байна уу эсвэл *захиалга* (order) болон *mail service* шиг төвөгтэй байна уу ? гэдэг байгаан.

Хэрэв хоорондын харилцаа нь хялбархан бол сонголт хийхэд амархан. Хэрэв би сонгодог TDD аргаар хөгжүүлэгч бол би ямар нэгэн *дууриамал объект* (*mock*), *stub*, *double*-уудыг ашиглахгүй. Би жинхэнэ объектууд болон төлвөөр батлах аргыг ашиглана. Хэрэв би дууриамал TDD аргаар хөгжүүлэгч бол дууриамал объектууд болон үйлдлээр батлах аргуудыг ашиглана. Шийдвэр гаргахад ямар ч асуудалгүй.

Хэрэв хоорондын харилцаа нь төвөгтэй бөгөөд би дууриамал TDD аргаар хөгжүүлэгч бол би дууриамал объектууд болон үйлдлээр батлах аргыг асуудалгүйгээр авч ашиглана. Харин би сонгодог аргааг хөгжүүлэгч бол надаа сонголт бий. Үүнд альнийг нь сонгох нь мөн тийм ч чухал биш. Ихэвчлэн сонгодог аргаар хөгжүүлэгчид тухайн байдлаасаа болоод аль амрыг нь сонгодог.

Бид төлвөөр эсвэл үйлдлээр батлах сонголтыг хийхэд тийм ч хүндрэлтэй биш гэдгийг харлаа. Гол асуудал нь сонгодог TDD юу эсвэл дууриамал TDD юу гэсэн сонголт юм. Төлвөөр батлах болон үйлдлээр батлах аргуудын зарчмууд энэхүү хэлэлцүүлэгт нөлөөлөх нь зайлшгүй бөгөөд үүнд би онцгой анхаарах болно.

Эхлэхээсээ өмнө би нэг хязгаарын нөхцөлийг дурьдахгүй бол болохгүй нь. Зарим үед объект хооронд харилцаа хялбар байсан ч төлвөөр батлах аргыг ашиглахад нилээд төвөгтэй байдаг. Үүний нэг сонгодог жишээ нь *cache* юм. Гол зүйл нь *cache* -ын тухайн төлвөөс та *cache hit* болсон уу *cache missed* болсныг хэлж чаддаггүй. Энэ нөхцөлд хэдийгээр та үнэнч сонгодог TDD аргыг баримтлагч байсан ч үйлдлээр батлах аргыг сонгосон нь дээр болохыг ойлгоно. Үүнтэй ижил мөн өөр олон төрлийн хязгаарын нөхцлүүд хоёр аргад хоёуланд байгаа гэдэгт би эргэлзэхгүй байна.

Сонгодог уу, эсвэл дууриамал аргаар хөгжүүлэгч үү гэсэн сонголтыг хийхэд бид нилээд хэдэн хүчин зүйлүүдийг авч үзэх шаардлагатай болохоор би дараах байдлаар тойм хэдэн бүлгүүдэд хуваасан болно.

## TDD -р хөтлөгдөх

Дууриамал объект бол XP -ийн бүлгээс гаралтай ба XP-ын гол онцлогуудын нэг нь Тестээр Хөтлөгдөх Хөгжүүлэлт (Test Driven Development) -ийн аргыг чухалчилдаг билээ. Үүнд системийн загварын хувьсал, өөрчлөлтүүд нь бичигдэх тестээр хөтлөгдөн давталтат (iterative) байдлаар хийгддэг.

Тиймээс дууриамал тестийн аргаар хөгжүүлэгчид тухайн арга системийн загварт хэрхэн нөлөөлдөг талаар тусгайлан авч үздгийг гайхах зүйлгүй юм. Ялангуяа тэд Need-driven development (шаардлагаас хөтлөгдөх хөгжүүлэлт) гэх аргыг зориуд дэмждэг. Энэ аргаар бол та user story (хэрэглэгчийн шаардлага, хэрэглэгдэх байдал) -ыг хөгжүүлэхдээ эхлээд системийн хамгийн гадна талаас нь тестлэх байдлаар эхэлж, SUT (System Under Test)-ынхаа интерфайсыг тодорхойлдог. Хамтрагч объектуудын хийгдэх үйлдлүүдийг нь олохдоо, SUT болон түүний хөрш объектуудыг хоорондын харилцааг судлан SUT-н outbound interface (хөрш объекттой харилцах гаралтын интерфэйс) -ыг судлан олдог.

Хамгийн эхний тест тань ажиллаж байгаа үед дууриамал объект дээр тодорхойлогдсон expectations (тэгнэ гэсэн хүлээлт)-үүд таны дараагын алхам дахь шаардлага болон хувчирч, тестлэх эхний алхам болдог. Ингэж expectation (тэгнэ гэсэн хүлээлт) бүрийг хамтрагч объектын тест болон хувиргах үйлдлийг систем рүү нэвтрэх давхрага SUT бүрт давтана. Энэ загварын аргыг мөн *outside-in* гэж нэрлэдэг ба энэ нь нилээд оновчтой тодорхойлсон нэр юм. Энэ загварчлалын арга layered system (давхаргат систем) -д нилээд сайн таарч ажилладаг. Та эхлээд UI (хэрэглэгчийн интерфэйс)-ыг програмчилах ба түүний доор давхаргуудыг дууриамилаар тодорхойлно. Ингэсний дараа та доорх давхарга нэг бүрт тест бичин аажмаар системийн давхарга бүрт нэвтрэн доошлоно. Энэ загварын арга бол маш зохион байгуулалтай, бүрэн хяналтыг олгодог тул олон хүмүүс ООП (OOP) -г болон TDD -г анхлагч суралцагчдад ихээхэн хэрэгтэй гэж итгэдэг.

Сонгодог TDD арга үүнтэй яг адил зааварчилгаа өгдөггүй. Хэдий тийм ч та mock-ын оронд stub-ыг ашиглан ижил төрлийн алхамаар загварчлах боломжтой. Ингэхийн тулд, SUT-г ажиллуулах тестэнд хамтрагч объектоос ямар нэгэн зүйл хэрэг болох бүртээ уг утгыг hard-coded байдлаар бичнэ. Ингээд та тестээ ногоон болсон үедээ hard-coded утгаа үнэн зөв кодоор сольно.

Сонгодог тестийн арга өөр бас онцлогтой. Нэг нь *middle-out* арга юм. Энэ аргад та шинээр хийгдэх feature-ээ сонгоод, тухайн feature ажиллахад домайн-с юу хэрэг болох талаар бодож, шийдвэр гаргана. Ингээд домайн объектууд юу хийгдэх ёстойг загварчилсныхаа дараа UI давхаргыг дээрээс нь тавин холбож ажиллуулна. Ингэж ажиллахад таньд магадгүй ямар ч дууриамал зүйл хэрэг болохгүй байх. Маш олон хүмүүс энэхүү аргад дуртай байдаг учир нь энэ арга хүний анхаарлыг эхлээд домайны загварчлал (domain model) -д төвлөрүүлдэг ба энэ нь домайны логикууд UI-аас хамаарахгүй байх боломжыг олгодог.

Мөн миний нэг онцолж хэлэх зүйл юу гэвэл сонгодог болон дууриамал загварчлалын аргаар хөгжүүлэгчид бүр тухайн нэг зүйлийг тухайн нэг цагт л хийдэг (do one at a time).
Мөн программын давхрага бүрийг нэг нэгээр нь дараалан гүйцэтгэх буюу нэг давхаргыг дуусгахаасаа өмнө хэзээ ч нөгөө нь эхлүүлэхгүй гэсэн зарчим нь бүр *school of thought* (цэгцтэй, мөрдөж дагадаг зарчмууд) ч болсон байдаг. Сонгодог болон дууриамал загварчлалаар хөгжүүлэгчид хоёул *Agile* аргачлал дээр суурьтай байдаг тул нарийн тусгаарлагдсан давталтат байдлаар (fine-grained iterations) хөгжүүлэхийг илүүд үздэг. Тиймээс тэд давхрага давхрагаар хөгжүүлэхээс илүүтэйгээр feature-үүдийг нэг нэгээр (feature by feature) нь авч ажиллахыг илүүд үздэг.


## Тестийн өгөгдлийг тодорхойлох

Сонгодог аргаар бол та SUT-ыг тестлэхийн тулд түүнийг хамтрагчуудыг мөн адил үүсгэж өгөх хэрэгтэй болно. Хэдийгээр дээрх жишээнд хэдхэн цөөхөн объектууд ашиглагдаж байгаа боловч жинхэнэ тестэнд олон тооны хамтрагч дэд объектууд шаардлагатай болдог. Ихэвчлэн эдгээр объектууд тест тус бүрт дээр шинээр үүсэж, мөн устгагдаг.

Харин дууриамал тестийн аргаар бол зөвхөн SUT л үүсдэг ба бусад хөрш, хамтрагч объектуудых нь оронд дууриамал объектуудыг ашигладаг. Ингэж илүү нүсэр тестийн өгөгдөл үүсгэхээс зайлхийж болдог. (Ямартай ч ингэж тодорхойлдог. Би нилээд төвөгтэй үүсгэгддэг дууриамал объектын бүтэц, байдалтай таарч байсан ч энэ маань магадгүй tool-үүдийг буруу ашигласнаас байж ч болох юм.)

Бодит байдал дээр сонгодог аргаар хөгжүүлэгчид цогц тестийн өгөгдлүүдийг дахин ашиглахыг илүү эрмэлздэг. Хамгийн энгийнээр бол та тодорхойлох өгөгдлүүдийг xUnit-ын *setup*  метод-д хийж өгнө. Харин олон классуудад ашиглагдах илүү цогц өгөгдлүүдлийн хувьд тусгайлан өгөгдлүүдийг үүсгэхээр зориулагдсан класс үүсгэж өгнө. Би ихэвчлэн эдгээр класуудыг ThoughtWorks -ын анхны XP төслүүдэд нэрлэж байсанчлан [Object Mother](http://martinfowler.com/bliki/ObjectMother.html)-ууд гэж нэрлэдэг. Том хэмжээний сонгодог тестүүдэд mother-уудыг ашиглах нь зайлшгүй боловч эдгээр mother-ууд нь илүүдэл тордолт, арчилгаа шаарддаг ба тэдгээрт хийгдэх өөрчлөлт бүр тестүүдэд хэд хэдэн давалгаалж нөлөөлдөг. Өгөгдлүүдийг тодорхойлох нь тестийн ажиллах хурданд мөн нөлөөлдөг боловч би үүнийг хэрэв зөв хийсэн тохиолдолд асуудал болсон гэж сонсоогүй л юмдаг. Зарим нэг онцгой давхар үүсгэгддэг объектуудаас бусад тохилдолд ихэнхдээ өгөдлүүдийн объектууд үүсгэхэд хялбархан байдаг.

Хачирхайлтай нь хоёр арга хоёулаа бие биенээ маш их ажиллагаатай гэж дүгнэдэг. Дууриамал тестийн аргаар хөгжүүлэгчид "тестийн өгөгдлийг үүсэх нь маш их ажиллагаатай" гэдэг бол харин сонгодогууд "эдгээр нь дахин ашиглагддаг харин та нар тест бүрт дууриамал объектууд үүсгэдэг" гэдэг.


## Тест тусгаарлалт

Хэрэв та дууриамал тесттэй хийгдсэн системд ямар нэгэн алдаа хийвэл, зөвхөн алдаатай SUT-ыг агуулсан тестүүд л ажиллахгүй болно. Харин сонгодог аргаар хийгдсэн системд алдаа хийвэл алдаатай объектыг агуулсан бүх тестүүд ажиллахгүй ба үүнд алдаатай объект бусад тестэнд хамтрагчаар орж ашиглагдаж байгаа тестүүд ч мөн орно. Үүнээс үүдээд олон дахин ашиглагдаж буй объектод гарах нэг алдаа нийт системийг хамарсан маш олон алдааг дагуулдаг.

Дууриамал аргаар хөгжүүлэгчид үүнийг маш том дутагдалтай тал гэж үздэг; учир нь алдааны  үндсэн шалтгааныг олж, засахын тулд маш олон тооны debug-ын хийх хэрэгтэй болдог. Харин сонгодог аргаар хөгжүүлэгчид үүнийг асуудал гэж үздэггүй. Ихэвчлэн алдаатай кодыг илрүүлэх нь нилээд хялбархан байдаг ба хөгжүүлэгч ажиллахгүй тестийг хараад л аль алдаа хаанаас үүдэлтэйг хэлж чаддаг. Мөн түүнчлэн хэрэв та байнга тестлэдэг бол (хэрэв үгүй бол, та тэгэх хэрэгтэй), гарсан алдаа тань таны хамгийн сүүлд өөрчилсөн кодоос үүсэлтэйг та мэдэж байдаг учираас алдааг олоход тийм ч хэцүү хүндрэлтэй байдаггүй.


Тестүүдийн бүтэц бүрэлдэхүүн, тогтоц (granularity) нь үүнд мөн нэгэн чухал хүчин нөхцөл болдог.  Сонгодог аргаар хөгжүүлэгдсэн тестүүд олон тооны жинхэнэ объектуудыг ажиллуулдаг тул ихэвчлэн нэг тест гэдэг бол нэг объектын тест гэхээс илүүтэйгээр олон тооны бүл объектуудыг тестлэх нэг бүлэг тест болдог. Хэрэв бүл олон тооны объектуудыг агуулдаг бол алдааны үндэс эх шалтгааныг олоход ихээхэн хүндрэл учирдаг. Энэ нь юу гэсэн үг вэ гэхлээр тэдгээр тестүүд нилээд бүдүүн бадаг, нарийн тодорхойлогдоогүй бүтэцтэй (coarse grained) байна гэсэн үг. 

Дууриамал аргаар хөгжүүлэгдсэн тестүүд дээрх хүндрэлтэй тулгарах нь нилээд ховор учир нь тухайн аргад - үндсэн тестлэгдэж буй объектоос бусад бүх объектыг дууриамлаар ашиглагддаг тул хамтрагч объектуудад нарийн тодорхойлогдсон (fine grained) тестүүд шаардлагатай болдог. Яг үндсэндээ бол бүдүүн бадаг, нарийн тодорхойлогдоогүй бүтэцтэй (coarse grained) тестүүд нь сонгодог аргын дутагталтай тал биш бөгөөд харин илүүтэйгээр сонгодог аргыг буруу ашигласны үр дүн гэж хэлж болох байх. Нэг сайн баримталбал зохих зарчим бол та класс бүхнээ яг нарийн тодорхойлогдсон тестээр тусгаарласан эхэсээ шалгаж байх хэрэгтэй. Хэдийгээр заримдаа бүл объектууд тестэнд хамрагдах учир шалтгаантай байдаг ч тооны хувьд цөөхөн байх учиртай - 5,6 -с хэтрэхгүй байвал зүгээр. Хэрэв та бүдүүн бадаг, нарийн тодорхойлогдоогүй бүтэцтэй (coarse grained) тестүүдэд алдаа олох (debuging хийх) болбол, та нарийн тодорхойлогдсон бүтэцтэй (fine grained) тестүүдийг үүсгэн, тестээр хөтлөгдөх аргаар цааш үргэлжлүүлэх хэрэгтэй.

Сонгодог XUnit тестүүд нь яг үндсэндээ нэгжийг тестлэх (unit) тестүүд биш ба мөн бага хэмжээний integration тестүүд юм. Ийм учираас үндсэн тестэнд илрүүлэгдээгүй алдаанууд дэд тестүүдэд заримдаа илэрдэг - ялангуяа классууд хоорондоо нарийн холбогдон харилцах үед - тул олон хүмүүс үүнд дуртай байдаг. Дууриамал аргаар хөгжүүлэгдсэн тестүүд энэ нь боломжгүй байдаг. Мөн түүнчлэн дууриамал тест дахь *тэгэх байх гэсэн нөхцөлүүд* (expectations) заримдаа буруу байх боломжтой тул хэдийгээр тестүүд зөв ажиллаж ногоон болох боловч алдааг нуух боломжтой.

Одоо миний онцлох хэрэгтэй нэг зүйл бол хэдийгээр аль ч тестийн аргыг та ашигласан бай та системийг бүхлээр нь хамрах нарийн тодорхойлогдооогүй (coarse grained) acceptance тестүүдтэй холбож өгөх хэрэгтэй. Би acceptance тестүүдийг төслийнхөө нилээд сүүлийн шатанд авч ашигласан ба үүндээ харамсдаг нилээдгүй олон тооны төслүүдтэй таарч байсныг хэлэх хэрэгтэй байх.