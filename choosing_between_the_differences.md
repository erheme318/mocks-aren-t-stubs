# Ялгаануудаас сонгох

Энэ нийтлэлд би дараах хос ялгаануудын талаар тайлбарлана: төлвөөр (state) батлах уу эсвэл үйлдлээр батлах уу / сонгодог TDD юу эсвэл дууриамал ТDD юу. Дээрх аргуудын нэгийг сонгохдоо ямар зарчмуудыг баримтлах хэрэгтэй вэ ? Эхлээд үйлдлээр батлахын эсрэг төлвөөр батлах аргыг авч үзье.

Эхний авч үзэх шаардлагатай зүйл нь тухайн нөхцөл байдал (context) юм. Бидний ажиллаж буй объект хоорондын харилцаа (collaboration) *захиалга* (order) болон *агуулах* (warehouse) хоёртой адилхан хялбархан байна уу эсвэл *захиалга* (order) болон *mail service* шиг төвөгтэй байна уу ? гэдэг байгаан.

Хэрэв хоорондын харилцаа нь хялбархан бол сонголт хийхэд амархан. Хэрэв би сонгодог TDD аргаар хөгжүүлэгч бол би ямар нэгэн *дууриамал объект* (*mock*), *stub*, *double*-уудыг ашиглахгүй. Би жинхэнэ объектууд болон төлвөөр батлах аргыг ашиглана. Хэрэв би дууриамал TDD аргаар хөгжүүлэгч бол дууриамал объектууд болон үйлдлээр батлах аргуудыг ашиглана. Шийдвэр гаргахад ямар ч асуудалгүй.

Хэрэв хоорондын харилцаа нь төвөгтэй бөгөөд би дууриамал TDD аргаар хөгжүүлэгч бол би дууриамал объектууд болон үйлдлээр батлах аргыг асуудалгүйгээр авч ашиглана. Харин би сонгодог аргааг хөгжүүлэгч бол надаа сонголт бий. Үүнд альнийг нь сонгох нь мөн тийм ч чухал биш. Ихэвчлэн сонгодог аргаар хөгжүүлэгчид тухайн байдлаасаа болоод аль амрыг нь сонгодог.

Бид төлвөөр эсвэл үйлдлээр батлах сонголтыг хийхэд тийм ч хүндрэлтэй биш гэдгийг харлаа. Гол асуудал нь сонгодог TDD юу эсвэл дууриамал TDD юу гэсэн сонголт юм. Төлвөөр батлах болон үйлдлээр батлах аргуудын зарчмууд энэхүү хэлэлцүүлэгт нөлөөлөх нь зайлшгүй бөгөөд үүнд би онцгой анхаарах болно.

Эхлэхээсээ өмнө би нэг хязгаарын нөхцөлийг дурьдахгүй бол болохгүй нь. Зарим үед объект хооронд харилцаа хялбар байсан ч төлвөөр батлах аргыг ашиглахад нилээд төвөгтэй байдаг. Үүний нэг сонгодог жишээ нь *cache* юм. Гол зүйл нь *cache* -ын тухайн төлвөөс та *cache hit* болсон уу *cache missed* болсныг хэлж чаддаггүй. Энэ нөхцөлд хэдийгээр та үнэнч сонгодог TDD аргыг баримтлагч байсан ч үйлдлээр батлах аргыг сонгосон нь дээр болохыг ойлгоно. Үүнтэй ижил мөн өөр олон төрлийн хязгаарын нөхцлүүд хоёр аргад хоёуланд байгаа гэдэгт би эргэлзэхгүй байна.

Сонгодог уу, эсвэл дууриамал аргаар хөгжүүлэгч үү гэсэн сонголтыг хийхэд бид нилээд хэдэн хүчин зүйлүүдийг авч үзэх шаардлагатай болохоор би дараах байдлаар тойм хэдэн бүлгүүдэд хуваасан болно.

## TDD -р хөтлөгдөх

Дууриамал объект бол XP -ийн бүлгээс гаралтай ба XP-ын гол онцлогуудын нэг нь Тестээр Хөтлөгдөх Хөгжүүлэлт (Test Driven Development) -ийн аргыг чухалчилдаг билээ. Үүнд системийн загварын хувьсал, өөрчлөлтүүд нь бичигдэх тестээр хөтлөгдөн давталтат (iterative) байдлаар хийгддэг.

Тиймээс дууриамал тестийн аргаар хөгжүүлэгчид тухайн арга системийн загварт хэрхэн нөлөөлдөг талаар тусгайлан авч үздгийг гайхах зүйлгүй юм. Ялангуяа тэд Need-driven development (шаардлагаас хөтлөгдөх хөгжүүлэлт) гэх аргыг зориуд дэмждэг. Энэ аргаар бол та user story (хэрэглэгчийн шаардлага, хэрэглэгдэх байдал) -ыг хөгжүүлэхдээ эхлээд системийн хамгийн гадна талаас нь тестлэх байдлаар эхэлж, SUT (System Under Test)-ынхаа интерфайсыг тодорхойлдог. Хамтрагч объектуудын хийгдэх үйлдлүүдийг нь олохдоо, SUT болон түүний хөрш объектуудыг хоорондын харилцааг судлан SUT-н outbound interface (хөрш объекттой харилцах гаралтын интерфэйс) -ыг судлан олдог.

Хамгийн эхний тест тань ажиллаж байгаа үед дууриамал объект дээр тодорхойлогдсон expectations (тэгнэ гэсэн хүлээлт)-үүд таны дараагын алхам дахь шаардлага болон хувчирч, тестлэх эхний алхам болдог. Ингэж expectation (тэгнэ гэсэн хүлээлт) бүрийг хамтрагч объектын тест болон хувиргах үйлдлийг систем рүү нэвтрэх давхрага SUT бүрт давтана. Энэ загварын аргыг мөн *outside-in* гэж нэрлэдэг ба энэ нь нилээд оновчтой тодорхойлсон нэр юм. Энэ загварчлалын арга layered system (давхаргат систем) -д нилээд сайн таарч ажилладаг. Та эхлээд UI (хэрэглэгчийн интерфэйс)-ыг програмчилах ба түүний доор давхаргуудыг дууриамилаар тодорхойлно. Ингэсний дараа та доорх давхарга нэг бүрт тест бичин аажмаар системийн давхарга бүрт нэвтрэн доошлоно. Энэ загварын арга бол маш зохион байгуулалтай, бүрэн хяналтыг олгодог тул олон хүмүүс ООП (OOP) -г болон TDD -г анхлагч суралцагчдад ихээхэн хэрэгтэй гэж итгэдэг.

Сонгодог TDD арга үүнтэй яг адил зааварчилгаа өгдөггүй. Хэдий тийм ч та mock-ын оронд stub-ыг ашиглан ижил төрлийн алхамаар загварчлах боломжтой. Ингэхийн тулд, SUT-г ажиллуулах тестэнд хамтрагч объектоос ямар нэгэн зүйл хэрэг болох бүртээ уг утгыг hard-coded байдлаар бичнэ. Ингээд та тестээ ногоон болсон үедээ hard-coded утгаа үнэн зөв кодоор сольно.

Сонгодог тестийн арга өөр бас онцлогтой. Нэг нь *middle-out* арга юм. Энэ аргад та шинээр хийгдэх feature-ээ сонгоод, тухайн feature ажиллахад домайн-с юу хэрэг болох талаар бодож, шийдвэр гаргана. Ингээд домайн объектууд юу хийгдэх ёстойг загварчилсныхаа дараа UI давхаргыг дээрээс нь тавин холбож ажиллуулна. Ингэж ажиллахад таньд магадгүй ямар ч дууриамал зүйл хэрэг болохгүй байх. Маш олон хүмүүс энэхүү аргад дуртай байдаг учир нь энэ арга хүний анхаарлыг эхлээд домайны загварчлал (domain model) -д төвлөрүүлдэг ба энэ нь домайны логикууд UI-аас хамаарахгүй байх боломжыг олгодог.

Мөн миний нэг онцолж хэлэх зүйл юу гэвэл сонгодог болон дууриамал загварчлалын аргаар хөгжүүлэгчид бүр тухайн нэг зүйлийг тухайн нэг цагт л хийдэг (do one at a time).
Мөн программын давхрага бүрийг нэг нэгээр нь дараалан гүйцэтгэх буюу нэг давхаргыг дуусгахаасаа өмнө хэзээ ч нөгөө нь эхлүүлэхгүй гэсэн зарчим нь бүр *school of thought* (цэгцтэй, мөрдөж дагадаг зарчмууд) ч болсон байдаг. Сонгодог болон дууриамал загварчлалаар хөгжүүлэгчид хоёул *Agile* аргачлал дээр суурьтай байдаг тул нарийн тусгаарлагдсан давталтат байдлаар (fine-grained iterations) хөгжүүлэхийг илүүд үздэг. Тиймээс тэд давхрага давхрагаар хөгжүүлэхээс илүүтэйгээр feature-үүдийг нэг нэгээр (feature by feature) нь авч ажиллахыг илүүд үздэг.


## Тестийн өгөгдлийг тодорхойлох

Сонгодог аргаар бол та SUT-ыг тестлэхийн тулд түүнийг хамтрагчуудыг мөн адил үүсгэж өгөх хэрэгтэй болно. Хэдийгээр дээрх жишээнд хэдхэн цөөхөн объектууд ашиглагдаж байгаа боловч жинхэнэ тестэнд олон тооны хамтрагч дэд объектууд шаардлагатай болдог. Ихэвчлэн эдгээр объектууд тест тус бүрт дээр шинээр үүсэж, мөн устгагдаг.

Харин дууриамал тестийн аргаар бол зөвхөн SUT л үүсдэг ба бусад хөрш, хамтрагч объектуудых нь дууриамал объектуудыг ашигладаг. Ингэж цогц тестийн өгөгдөл үүсгэхээс зайлхийж болдог. (Ямартай ч ингэж тодорхойлдог. Би нилээд төвөгтэй үүсгэгддэг дууриамал объектын бүтэц, нөхцөл байдалтай учир ч байсан бөгөөд энэ магадгүй tool-үүдийг буруу ашигласнаас байж болох юм.)

Бодит байдал дээр сонгодог аргаар хөгжүүлэгчид цогц тестийн өгөгдлүүдийг дахин ашиглахыг илүүтэй эрмэлздэг. Хамгийн энгийнээр бол та тодорхойлох өгөгдлүүдийг xUnit-ын *setup*  метод-д хийж өгнө. Харин олон классуудад ашиглагдах илүү цогц өгөгдлүүдлийн хувьд тусгайлан өгөгдлүүдийг үүсгэхээр зориулагдсан класс үүсгэж өгнө. 









